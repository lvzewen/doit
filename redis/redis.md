# redis

## Redis是啥?

Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.

Redis是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件。Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。

## Redis内部要处理的问题

1. 数据结构
Redis不仅仅是数据存储器，而是数据结构存储器。那是因为Redis支持客户端直接往里面塞各种类型的数据结构，比如String、List、Set、SortedSet、Map等等
2. 剔除策略
3. 负载均衡
4. Presharding
5. 数据持久化
6. 数据同步

## Redis 优势

性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets数据类型操作。
原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。

## Redis与其他key-value存储有什么不同？

Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。
Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。

## Redis 数据类型

Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。

1. String（字符串）
string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。
string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。
string类型是Redis最基本的数据类型，一个键最大能存储512MB。

2. Hash（哈希）
Redis hash 是一个键名对集合。
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

3. List（列表）
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。

4. Set（集合）
Redis的Set是string类型的无序集合。
集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

5. set(sorted set：有序集合)
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员是唯一的,但分数(score)却可以重复。

## Redis 基础命令

用于Key的命令

SET : 为Key设置值，实例：SET runoobkey redis
EXISTS : 查询Key是否存在，存在返回1，否则返回0。实例：EXISTS runoob-new-key
PPTL : 以毫秒为单位返回 key 的剩余过期时间。实例：PTTL KEY_NAME
TTL : 秒为单位返回 key 的剩余过期时间。 实例： TTL KEY_NAME
用于字符串的命令
SET : 设置指定key的值。实例：SET KEY_NAME value
GET : 获取指定key的值。实例：GET KEY_NAME
INCR : 把key中存储的数字值增1。实例：INCR KEY_NAME
DECR : 把key中存储的数字值减1。实例：DECR KEY_NAME
用于Hash表的命令
HGET : 获取hash表中的指定字段的值。实例：HGET KEY_NAME FIELD_NAME
HGETALL : 获取hash表中所有字段和 对应的值。实例：HGETALL KEY_NAME
HKEYS : 获取hash表中所有字段。实例：HKEYS KEY_NAME
用于List集合的命令
LRANGE : 获取集合指定范围内的元素。实例：LRANGE key start stop 获取下标从start到stop的元素

## 异步队列

概念：redis实现异步队列，一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

## Redis集群篇

### 一致性哈希

1. 普通的HASH算法的缺点：
在使用Redis集群的时候，如果直接使用HASH算法 hash(key) % length，当缓存服务器变化时，length字段变化，导致所有缓存的数据需要重新进行HASH运算，才能使用。而这段时间如果访问量上升了，容易引起服务器雪崩。因此，引入了一致性哈希
2. 一致性哈希：
通过对2^32取模的方式，保证了在增加/删除缓存服务器的情况下，其他缓存服务器的缓存仍然可用，从而不引起雪崩问题。

### Redis Cluster

Redis Cluster是一种服务器Sharding技术，3.0版本开始正式提供。Redis Cluster中，Sharding采用slot(槽)的概念，一共分成16384个槽，这有点儿类似前面讲的pre sharding思路。对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。使用的hash算法也比较简单，就是CRC16后16384取模。Redis集群中的每个node(节点)负责分摊这16384个slot中的一部分，也就是说，每个slot都对应一个node负责处理。当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程，在目前实现中，还处于半自动状态，需要人工介入。Redis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，整个集群继续对外提供服务。这非常类似前篇文章提到的Redis Sharding场景下服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。
Redis Cluster的新节点识别能力、故障判断及故障转移能力是通过集群中的每个node都在和其它nodes进行通信，这被称为集群总线(cluster bus)。它们使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。

### Redis Sharding集群

### Redis缓存篇

#### Redis主从同步原理

和MySQL主从复制的原因一样，Redis虽然读取写入的速度都特别快，但是也会产生读压力特别大的情况。为了分担读压力，Redis支持主从复制，Redis的主从结构可以采用一主多从或者级联结构

##### Redis主从结构

Redis主从复制可以根据是否是全量分为全量同步和增量同步。

1. 全量同步
Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：
　　1）从服务器连接主服务器，发送SYNC命令；
　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；
　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；
　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；
　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；
　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；
2. 增量同步
Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。
3. Redis主从同步策略
主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。
4. 其他：Redis 2.8以后提供了PSYNC优化了断线重连的效率。

#### 缓存雪崩

##### 详情

如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。并且如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象

##### 解决方法

1、使用互斥锁（这里使用redis的setnx实现分布式锁）：
只有获取锁，才能去访问数据库，加载数据，保证同一时刻只有一个请求访问数据库，避免数据库崩溃。但这样子可能造成请求延时比较久的问题。

2、让缓存过期时间不那么集中：
比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件

3、做二级缓存
A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2。A1缓存失效时间设置为短期，A2设置为长期。这个在业务追求数据一致性要求不高的情况下，可以使用。

4、缓存永远不过期
这里的“永远不过期”包含两层意思：
(1) 从缓存上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期.

### 缓存穿透

#### 详情

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透

#### 解决方法

使用Bloom filter（布隆过滤器）。当用户查询某个row时，可以先通过内存中的布隆过滤器过滤掉大量不存在的row请求，然后再到数据库进行查询。

链接 `https://segmentfault.com/a/1190000013333723`